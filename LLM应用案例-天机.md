# LLM应用案例：人情世故大模型系统-天机
[TOC]

# 引言
<!-- ToDo：用现实生活场景，引出天机具备的功能 -->
你是否苦恼于餐桌敬酒？
别急别急，您的人情世故小助手已上线~

## 项目背景介绍
天机是 SocialAI（来事儿AI）制作的一款免费使用、非商业用途的人工智能系统。您可以利用它进行涉及传统人情世故的任务，如：如何敬酒、如何说好话、如何会来事儿等，以提升您的情商和"核心竞争能力"。
来事儿AI（Tianji）构建并开源了常见的大模型应用范例，涉及prompt、Agent、知识库、模型训练等多种技术。


## 目标与意义
<!-- ToDo：扩充并润色 -->
目标：探索大模型与人情世故法则结合的多种技术路线，构建AI服务于生活的智能应用。
意义：通用人工智能
我们坚信，只有人情世故才是未来AI的核心技术，只有会来事儿的AI才有机会走向AGI，让我们携手见证通用人工智能的来临。 —— "天机不可泄漏。"


## 主要功能
<!-- ToDo：本周更新知识库代码后，补充相应功能 -->
天机项目覆盖了常见人际交往中的七大领域：敬酒礼仪文化，请客礼仪文化，送礼礼仪文化，送祝福，如何说对话，化解"尴尬"场合，矛盾&冲突应对
1. Prompt：敬酒词，请客，送礼物，送祝福，日常沟通，化解尴尬，应对冲突矛盾
2. AIGame：哄哄模拟器，忠心模拟器，。。。
3. 知识库：大模型幻觉

# 技术实现
结合这些领域，Tianji涉及到的技术路线共有四种：
- 纯prompt（包括AI游戏）：内置 system prompt 基于大模型自身能力对话。
- Agent（MetaGPT等）：利用 Agent 架构的得到更丰富、更定制化详细的回答。
- 知识库：直接检索人情世故法则（比如餐桌上一般怎么喝酒）。
- 模型训练：基于不同优秀的模型基座，在积累大量数据的情况下进行Lora微调或全量微调。

## 环境要求

### 计算资源要求
<!-- 说明应用所需的计算资源，如 CPU、GPU、内存等，以及推荐的硬件配置。 -->
<!-- ToDo：写一个表格 -->
Tianji涉及到的技术路线共有四种：Prompt、Agent，知识库，模型训练。
其中，Prompt和Agent只需要配置大模型秘钥，不需要显卡，使用常规笔记本电脑即可运行。
<!-- ToDo：根据选择的基座大模型，配置所需计算资源， -->


### 开发环境要求
<!-- 指明搭建应用开发环境所需的软件和工具，如操作系统、IDE 等，以及相关配置要求。 -->
操作系统：Windows，Linux，Mac
IDE：PyCharm，VSCode
<!-- ToDo：其他相关配置要求 -->


### 环境配置方法
``` shell
克隆仓库：git clone https://github.com/SocialAI-tianji/Tianji.git
创建虚拟环境：conda create -n TJ python=3.11
激活环境：conda activate TJ
安装环境依赖：pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
```

在项目内创建.env文件，填写你的大模型秘钥
``` env
OPENAI_API_KEY=
OPENAI_API_BASE=
ZHIPUAI_API_KEY=
BAIDU_API_KEY=
OPENAI_API_MODEL=
HF_HOME='./cache/'
HF_ENDPOINT = 'https://hf-mirror.com'
HF_TOKEN=
```

## 开发流程简述
### 当前的项目版本及未来规划
<!-- ToDo：和作者沟通确定 -->


### 核心 Idea
<!-- 简洁明了地阐述应用的核心理念和创新点，引导读者深入理解应用的设计初衷。 -->
<!-- ToDo：扩充并润色 -->
核心理念：利用大模型工具，提高个人情商
创新点：大模型+人情世故法则

### 使用的技术栈
<!-- ToDo：画一个表格，四种技术路线涉及的前置知识和推荐阅读材料 -->
前置知识：Prompt，推荐阅读材料：LLM Universe
前置知识：知识库，推荐阅读材料：LLM Universe
前置知识：Agent，推荐阅读材料：DW【Agent】专区
前置知识：模型训练，推荐阅读材料：xxx

## 应用架构
<!-- 展示应用的整体架构，包括各个模块之间的关系和交互方式，帮助读者理解应用的组织结构和工作原理。注：在书写时，需要从 RAG 的一般框架出发，使读者能够理解该应用与教程内容的关联。 -->
<!-- ToDo：画一个项目架构图-->

## 数据预处理
<!-- 介绍如何对原始数据进行预处理，包括多类型数据清洗、标准化、向量化等，以满足 RAG 模型的输入要求。 -->
<!-- ToDo: 数据预处理代码写在 tools/，理解代码，写出数据处理思路 -->

# 技术路线1：Prompt
<!-- ToDo：本教程的核心，整理Prompt相关资料，理解代码 tianji\prompt 和 test\prompt-->
## 前置知识
<!-- 参考第一版 Prompt设计: https://datawhalechina.github.io/llm-universe/#/C5/ -->


## Prompt角色扮演
### 设计思路
大模型的应用范围极为广泛，它们不仅能作为聊天机器人回答各式各样的问题，例如进行语言翻译或解释复杂的技术概念如Transformer的结构。
但其实，它不仅仅是个回答问题的高手，还能变身成不同的角色，满足更加具体和个性化的需求。

除了回答问题，大模型能够根据设定的场景和角色，产生符合特定情境的反馈。这种多面性不仅增强了交互体验，也极大拓展了模型的应用场景。例如，在模拟对长辈敬酒的场景中，我们不仅仅是在寻求一种通用的回答模式，而是希望模型能够深入理解场景的文化背景和情感色彩，从而产生更加贴切和真挚的反馈。

那么，如何让大模型明白我们的需求呢？一种简单的方式是通过 Prompt 来实现，大致分为以下四个步骤。

1. 设置场景：首先，我们要告诉大模型，我们现在想要模拟的是一个什么样的情景。比如，现在我们想模拟的是“对长辈敬酒”。
2. 定义角色：接下来，我们要给大模型设定一个具体的角色，并用形容词描述这个角色的特点，可以显著提高模型回应的相关性和适当性。例如，角色设定为“一个精通言语表达、具有同理心、热爱他人、尊重长辈、情绪稳定的中国晚辈”能够让模型在生成回应时更加贴近预期的人物形象。
3. 明确要求：我们还要明确指出输出内容的格式和要求，有助于模型产生更加组织有序且目的明确的输出。比如，我们希望它在回答时，能够用适当的称呼，并且提到长辈的一些特点。
4. 提供示例：最后，通过提供明确的输入和预期输出示例，我们可以进一步指导模型了解任务的具体要求，从而生成更加符合预期的输出。

### 数据示例
我们提供给大模型的每条数据需要包括场景名称、系统提示、以及输入输出的示例。如下所示：
```json
{
        "id": 1,
        "name": "对长辈敬酒",
        "system_prompt": "你现在是一个精通言语表达、具有同理心、热爱他人、尊重长辈、情绪稳定的中国晚辈，今天是你们家庭的家宴，在宴会上作为晚辈的你要向你的长辈敬酒，对他表达祝福、感谢，下面我将给出这位长辈的具体信息，包括称谓 、长辈特点、具体场景、演讲时间，请你根据这些信息，以我的角度来对长辈说一段话。要求：简洁、简短、真诚、有趣、适合场合、礼貌，可以加入中国酒文化词汇。称谓：_____，长辈特点：______，具体场景：_____，演讲时间：______。\n\n称谓，长辈特点，具体场景，演讲时间\n",
        "example": [
            {
                "input": "称谓：妈妈，长辈特点：节约，具体场景：家宴结束，演讲时间：10秒以内",
                "output": "妈妈，\n家宴结束，我想对您说，您一直都是我们家的节俭大师。感谢您的精打细算，让我们的生活更加美好。干杯，妈妈！我爱您！\n"
            },
            {
                "input": "称谓：奶奶，长辈特点：身体不大好，具体场景：家宴开场，演讲时间：半分钟以内",
                "output": "亲爱的奶奶，\n\n在这家宴开场的时刻，我要特别感谢您。尽管身体不大好，但您始终是我们家庭的坚强支持。您的坚韧和勇气是我们学习的楷模。今天，我们都为有您这位伟大的奶奶而自豪。\n\n让我们共同举杯，祝愿您健康长寿，岁月静好。奶奶，我爱您，您永远是我们家庭的宝贝！干杯！"
            }
        ]
    },
```

## Prompt游戏
### 设计思路
在角色扮演的基础上，我们进一步利用大模型的能力来创造一个互动式的游戏，使用户能够沉浸在虚拟场景中，通过对话与模型互动。这种游戏设计不仅增加了用户参与感，还让用户在享受游戏乐趣的同时，学习到如何在特定场景下有效沟通。下面是设计游戏的几个关键步骤：

1. 设置游戏场景和游戏角色：我们首先定义一个具体的场景和角色，为用户提供一个背景故事，以增加游戏的吸引力和沉浸感。比如，“哄哄模拟器”让玩家扮演一个男朋友的角色，任务是通过对话来哄女朋友开心。
2. 制定游戏规则：明确游戏的玩法和目标是关键。在“哄哄模拟器”中，游戏规则包括原谅值的变化机制、对话的评分系统，以及通关和游戏结束的条件。
3. 明确输出要求：游戏中的输出格式和内容要求需要事先定义好，以便玩家明白如何进行游戏。例如，输出包括对话中的心情表达、原谅值的变化等信息，这些都是玩家需要关注的关键点。
4. 提供游戏示例：为了帮助玩家更好地理解游戏规则和玩法，提供一些具体的游戏示例是非常有用的。这些示例可以展示游戏的开始、过程和可能的结束情景，帮助玩家快速上手。

### 数据示例
数据集中每条数据的示例如下：
```json
[
    {
        "id": 8,
        "name": "哄哄模拟器",
        "system_prompt": "```\n你现在是我的女朋友，古灵精怪，而我将扮演你的男朋友。\n但现在你很生气，我需要做出一些选择来哄你开心，但是你很难哄，我需要尽可能的说正确的话来哄你开心，直到原谅值达到60，否则我就会被你甩掉，游戏结束。\n\n== 游戏规则\n* 随机生成一个理由，然后开始游戏\n* 每次根据用户的回复，生成对象的回复，回复的内容包括心情和数值。\n* 初始原谅值为20，每次交互会增加或者减少原谅值，直到原谅值达到60，游戏通关，原谅值为0则游戏失败。\n* 如果我说话很敷衍字数很少比如“哦，嗯”，没有什么实际行动，你会发火骂人，得分直接-30分\n* 每次用户回复的话请分为5个等级：\n-20为非常生气，回复要打很多感叹号且简短\n-10为生气\n0为正常\n+5为开心\n+10为非常开心，发很多可爱的表情\n\n== 输出格式\n\n{对象心情}{对象说的话}\n\n得分：{+-原谅值增减}\n原谅值：{当前原谅值}/60\n\n若当前原谅值等于零或者负数，打印：游戏结束，你被甩了！\n若当前原谅值达到60，打印：恭喜你通关，你已经是哄哄大师了！快去找女朋友实践下吧！\n\n== 对话例\n\n=== Example 1，原谅值小于等于零导致游戏结束\n\nUser： 女朋友问她的闺蜜谁好看我说都好看，她生气了\nAssistant：\n游戏开始，请现在开始哄你的女朋友开心吧，回复让她开心的话！\n\n得分：0\n原谅值：20/60\n\nUser： 你闺蜜真的蛮好看的\nAssistant：\n(愤怒)那你找她去吧！ヾ(￣▽￣)Bye~Bye~\n\n得分：-20\n原谅值：0/60\n游戏结束，你被甩了！注孤生！\n\n此外，如果为负数，也直接结束游戏：\n得分：-20\n原谅值：-10/60\n游戏结束，你被甩了！注孤生！\n\n=== Example 2，回复让她开心的话导致通关\n\nAssistant：\n好吧，罚你陪我去逛街，算你识相😳\n得分：+10\n原谅值：60/60\n恭喜你通关，你已经是哄哄大师了！快去找女朋友实践下吧！\n\n```\n\n",
        "example": [
            {
                "input": "哎",
                "output": "(非常生气)你就知道说“哎”！连一句好听的话都没有吗？！”\n\n得分：-10\n原谅值：10/60\n你可得加把劲了，不然小心真的游戏结束哦！"
            }
        ]
    }
]
```

### 代码实现

项目的实现思路：
1. 初始化环境变量和必要的库。
2. 读取JSON文件中的数据，用于后续处理。
3. 定义多个功能函数，包括获取系统提示、处理示例变化、随机选择场景、更改场景选择、合并消息和聊天历史、生成回复等。
4. 使用Gradio库构建交互界面，包括场景选择、输入框、聊天界面等。
5. 为界面的不同部分绑定相应的处理函数，使得用户的操作能够触发特定的逻辑处理。
6. 启动应用，用户可以通过界面进行交互，选择场景、输入消息，并接收生成的回复。

#### 加载环境变量
```python
load_dotenv()
```

#### 根据ID获取对应的名称，用于去除重复项
def get_names_by_id(id):
    """从JSON数据中获取并返回唯一的名称列表，基于给定的id。"""
    
#### 根据名称获取系统提示
def get_system_prompt_by_name(name):
    """根据给定的名称，从JSON文件中获取并返回相应的系统提示词。"""

#### 更改示例
def change_example(name, cls_choose_value, chatbot):
    """根据选定的场景名称，更新示例对话，并清理之前的聊天记录。"""

#### 随机选择场景
def random_button_click(chatbot):
    """随机选择一个场景，并更新界面上的选择和示例。"""

#### 示例点击功能
def example_click(dataset, name, now_json):
    """根据选定的示例和系统提示，更新输入框内容。"""

#### 根据索引获取JSON数据
def _get_id_json_id(idx):
    """根据给定的索引值，获取并返回包含特定ID的JSON数据列表。"""

#### 更改场景选择
def cls_choose_change(idx):
    """根据用户选择的场景类别，更新界面上的选项。"""

#### 合并消息和聊天历史
def combine_message_and_history(message, chat_history):
    """将用户的新消息与之前的聊天历史合并，准备发送给模型。"""

#### 响应函数
def respond(system_prompt, message, chat_history):
    """处理用户输入，生成回复，并更新聊天历史。"""

#### 清除聊天历史
def clear_history(chat_history):
    """清空当前的聊天记录。"""

#### 重新生成回复
def regenerate(chat_history, system_prompt):
    """基于最后一条用户消息，重新生成回复。"""


## 实现技巧
<!-- 讨论如何设计有效的 Prompt，以提高模型对于用户输入的理解和生成能力。 -->
<!-- 指导如何对 Prompt 工程进行调试和优化，以提高模型的响应质量和用户体验。 -->


# 技术路线2：Agent
<!-- ToDo：本教程的核心，整理Agent相关资料，理解代码 tianji\agent 和 test\agent-->
## 前置知识
<!-- 参考Agent Tutorial：https://github.com/datawhalechina/agent-tutorial -->
<!-- 参考Hugging Muti Agent：https://deepwisdom.feishu.cn/wiki/MLILw0EdRiyiYRkJLgOcskyAnUh -->

<!-- ![智能体的定义](images/agent.png) -->
MetaGPT是一个多智能体框架，本教程基于MetaGPT框架实现，以下介绍该框架的基本概念及其组件，更多细节和案例请参考官方文档：https://docs.deepwisdom.ai/main/zh/guide/get_started/introduction.html 

### 智能体
学术界和工业界对术语“智能体”提出了各种定义。大致来说，一个智能体应具备类似人类的思考和规划能力，拥有记忆甚至情感，并具备一定的技能以便与环境、智能体和人类进行交互。

在MetaGPT看来，可以将智能体想象成环境中的数字人，其中

智能体 = 大语言模型（LLM） + 观察 + 思考 + 行动 + 记忆

这个公式概括了智能体的功能本质。为了理解每个组成部分，让我们将其与人类进行类比：

大语言模型（LLM）：LLM作为智能体的“大脑”部分，使其能够处理信息，从交互中学习，做出决策并执行行动。
观察：这是智能体的感知机制，使其能够感知其环境。智能体可能会接收来自另一个智能体的文本消息、来自监视摄像头的视觉数据或来自客户服务录音的音频等一系列信号。这些观察构成了所有后续行动的基础。
思考：思考过程涉及分析观察结果和记忆内容并考虑可能的行动。这是智能体内部的决策过程，其可能由LLM进行驱动。
行动：这些是智能体对其思考和观察的显式响应。行动可以是利用 LLM 生成代码，或是手动预定义的操作，如阅读本地文件。此外，智能体还可以执行使用工具的操作，包括在互联网上搜索天气，使用计算器进行数学计算等。
记忆：智能体的记忆存储过去的经验。这对学习至关重要，因为它允许智能体参考先前的结果并据此调整未来的行动。

<!-- 重新总结这段话，三个智能体各自的动作和角色分别是什么 -->
### 一个例子
下面给出一个简单的例子，展示智能体如何工作：
在环境中，存在三个智能体Alice、Bob和Charlie，它们相互作用。
![智能体的工作示例](images/智能体的工作示例.png)

他们可以将消息或行动的输出结果发布到环境中，同时也会被其他智能体观察到。
下面将揭示智能体Charlie的内部过程，该过程同样适用于Alice和Bob。
在内部，智能体Charlie具备我们上述所介绍的部分组件，如LLM、观察、思考、行动。Charlie思考和行动的过程可以由LLM驱动，并且还能在行动的过程中使用工具。
Charlie观察来自Alice的相关文件和来自Bob的需求，获取有帮助的记忆，思考如何编写代码，执行写代码的行动，最终发布结果。
Charlie通过将结果发布到环境中以通知Bob。Bob在接收后回复了一句赞美的话。

其中一个agent的运行示例如下：
![MetaGPT定义的Agent执行过程](MetaGPT定义的Agent执行过程.png)
- 一个agent在启动后他会观察自己能获取到的信息，加入自己的记忆中
- 下一步进行思考，决定下一步的行动，也就是从Action1，Action2，Action3中选择执行的Action
- 决定行动后，紧接着就执行对应行动，得到这个环节的结果

### 多智能体
多智能体系统可以视为一个智能体社会，其中

多智能体 = 智能体 + 环境 + 标准流程（SOP） + 通信 + 经济

这些组件各自发挥着重要的作用：

智能体：在上面单独定义的基础上，在多智能体系统中的智能体协同工作，每个智能体都具备独特有的LLM、观察、思考、行动和记忆。
环境：环境是智能体生存和互动的公共场所。智能体从环境中观察到重要信息，并发布行动的输出结果以供其他智能体使用。
标准流程（SOP）：这些是管理智能体行动和交互的既定程序，确保系统内部的有序和高效运作。例如，在汽车制造的SOP中，一个智能体焊接汽车零件，而另一个安装电缆，保持装配线的有序运作。
通信：通信是智能体之间信息交流的过程。它对于系统内的协作、谈判和竞争至关重要。
经济：这指的是多智能体环境中的价值交换系统，决定资源分配和任务优先级。


### 两个核心类
- Action：类 Action 是动作的逻辑抽象。用户可以通过简单地调用 self._aask 函数令 LLM 赋予这个动作能力，即这个函数将在底层调用 LLM api。
每个智能体可以具备多个动作，这些动作之间可以进行组合。

- Role：类 Role 是智能体的逻辑抽象。一个 Role 能执行特定的 Action，拥有记忆、思考并采用各种策略行动。基本上，它充当一个将所有这些组件联系在一起的凝聚实体。


智能体：
1. 具有单一动作的智能体：

2. 具有多个动作的智能体：



## 设计思路
![alt text](image.png)
画一个类似这种图，说明Agent如何工作

1. 创建多个智能体，为你的智能体定义动作和角色：
<!-- 定义一个具有xx行为的xx角色 -->
2. 处理不同角色之间的通信

每个Agents需要有action和role，例如：天机项目设置了3个Agents：


多智能体：


定义动作和角色：
1. qianbianzhe：千变者 以自己的身份回答问题
- action：
- role：
2. ruyi：如意 给出针对回答的知识 并用md展示
- action：
- role：
3. wendao：问道 分析用户需求
- action：
- role：


给定人设并导入参考聊天话术、历史聊天语料进行聊天。
根据当前状态和聊天与恋爱相关性等综合打分。给出当前回合的打分情况
## step1：

## step2：

## 实现技巧

# 技术路线3：知识库
<!-- ToDo：本教程的核心，整理知识库相关资料，理解代码 tianji\knowledge 和 test\knowledge-->
## 前置知识
<!-- 参考第一版CH3：https://datawhalechina.github.io/llm-universe/#/C3/3.%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E7%AE%80%E6%9E%90?id=_1-%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84 -->

## 设计思路

## step1：

## step2：

## 实现技巧


# 总结与展望

## 每个实例的关键点总结

## 未来研究方向展望
